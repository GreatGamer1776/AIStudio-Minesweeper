<!DOCTYPE html>
<html lang="en"> <!-- Dark class will be added here by JS -->
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Minesweeper</title>

    <!-- TAILWIND CONFIGURATION SCRIPT -->
    <!-- This MUST come BEFORE the main Tailwind CDN script -->
    <script>
        tailwind.config = {
            darkMode: 'class', // This tells Tailwind to look for the .dark class on an ancestor
            theme: {
                extend: {
                    // You can add other custom theme extensions here if needed
                }
            }
        }
    </script>
    <script src="https://cdn.tailwindcss.com"></script>

    <style>
        /* Ensuring Inter font is prioritized */
        body {
            font-family: 'Inter', ui-sans-serif, system-ui, -apple-system, BlinkMacSystemFont, "Segoe UI", Roboto, "Helvetica Neue", Arial, "Noto Sans", sans-serif, "Apple Color Emoji", "Segoe UI Emoji", "Segoe UI Symbol", "Noto Color Emoji";
        }
        /* Custom class for the 'explosion' effect on the clicked mine */
        .mine-hit {
            animation: mine-explosion 0.5s ease-out;
        }
        @keyframes mine-explosion {
            0% { transform: scale(1); opacity: 1; }
            50% { transform: scale(1.5); opacity: 0.7; }
            100% { transform: scale(1); opacity: 1; }
        }
    </style>
    <link rel="preconnect" href="https://fonts.googleapis.com">
    <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
    <link href="https://fonts.googleapis.com/css2?family=Inter:wght@400;500;700;900&display=swap" rel="stylesheet">
</head>
<body class="bg-slate-100 dark:bg-slate-900 text-slate-800 dark:text-slate-200 flex flex-col items-center justify-center min-h-screen p-2 sm:p-4 select-none transition-colors duration-300">

    <div class="game-container bg-slate-200 dark:bg-slate-800 p-3 sm:p-4 md:p-6 rounded-xl shadow-xl w-full max-w-xs sm:max-w-sm md:max-w-md lg:max-w-lg transition-colors duration-300">
        <header class="flex justify-between items-center mb-3 sm:mb-4">
            <div id="mine-counter" class="bg-slate-800 dark:bg-slate-700 text-white dark:text-slate-100 px-3 py-1.5 rounded-lg text-lg sm:text-xl font-mono shadow-sm tabular-nums transition-colors duration-300">
                M:015
            </div>
            <div class="flex items-center space-x-2">
                <button id="reset-button" class="bg-blue-500 hover:bg-blue-600 active:bg-blue-700 dark:bg-blue-600 dark:hover:bg-blue-500 dark:active:bg-blue-700 text-white font-bold py-1.5 px-3 sm:py-2 sm:px-4 rounded-lg text-base sm:text-lg shadow-sm transition-colors focus:outline-none focus:ring-2 focus:ring-blue-400 dark:focus:ring-blue-500 focus:ring-opacity-75">
                    🙂
                </button>
                <button id="theme-toggle" class="bg-slate-700 hover:bg-slate-600 active:bg-slate-800 dark:bg-slate-300 dark:hover:bg-slate-400 dark:active:bg-slate-500 text-white dark:text-slate-800 font-bold py-1.5 px-3 sm:py-2 sm:px-4 rounded-lg text-base sm:text-lg shadow-sm transition-colors focus:outline-none focus:ring-2 focus:ring-slate-400 dark:focus:ring-slate-500 focus:ring-opacity-75">
                    Mode
                </button>
            </div>
            <div id="timer" class="bg-slate-800 dark:bg-slate-700 text-white dark:text-slate-100 px-3 py-1.5 rounded-lg text-lg sm:text-xl font-mono shadow-sm tabular-nums transition-colors duration-300">
                T:000
            </div>
        </header>

        <div id="status-message" class="text-center text-xl sm:text-2xl font-bold py-2 sm:py-3 mb-2 sm:mb-3 rounded-lg hidden transition-all">
            <!-- Game status will appear here -->
        </div>

        <div id="game-board" class="grid gap-0.5 sm:gap-1 bg-slate-400 dark:bg-slate-600 p-0.5 sm:p-1 rounded-lg shadow-inner transition-colors duration-300">
            <!-- Cells will be generated by JavaScript -->
        </div>
    </div>

    <footer class="mt-4 sm:mt-6 text-center text-xs sm:text-sm text-slate-600 dark:text-slate-400 transition-colors duration-300">
        <p>Left-click to reveal. Right-click or long-press (mobile) to flag.</p>
    </footer>

    <script>
        const gameBoardElement = document.getElementById('game-board');
        const mineCounterElement = document.getElementById('mine-counter');
        const timerElement = document.getElementById('timer');
        const resetButtonElement = document.getElementById('reset-button');
        const statusMessageElement = document.getElementById('status-message');
        const themeToggleButton = document.getElementById('theme-toggle');
    
        const ROWS = 10;
        const COLS = 10;
        const NUM_MINES = 15;
    
        let boardData = [];
        let gameState = 'initial'; 
        let minesToFlag = 0;
        let revealedSafeCells = 0;
        const totalSafeCells = ROWS * COLS - NUM_MINES;
    
        let timerInterval;
        let secondsElapsed = 0;
        let firstClick = true;
    
        const numberColors = [
            '',
            'text-blue-600 dark:text-blue-400',
            'text-green-600 dark:text-green-400',
            'text-red-600 dark:text-red-400',
            'text-purple-700 dark:text-purple-400',
            'text-yellow-700 dark:text-yellow-400',
            'text-cyan-600 dark:text-cyan-400',
            'text-slate-800 dark:text-slate-200',
            'text-slate-500 dark:text-slate-400'
        ];
    
        function initGame() {
            try {
                gameState = 'initial';
                firstClick = true;
                secondsElapsed = 0;
                revealedSafeCells = 0;
                minesToFlag = NUM_MINES;
    
                clearInterval(timerInterval);
                updateTimerDisplay();
                updateMineCounterDisplay();
                if(resetButtonElement) resetButtonElement.textContent = '🙂';
    
                if(statusMessageElement) {
                    statusMessageElement.classList.add('hidden');
                    statusMessageElement.textContent = '';
                    statusMessageElement.classList.remove(
                        'bg-green-100', 'text-green-700', 'dark:bg-green-800', 'dark:text-green-200',
                        'bg-red-100', 'text-red-700', 'dark:bg-red-800', 'dark:text-red-200'
                    );
                }
    
                createBoardDataStructure();
                placeMines();
                calculateAdjacentMines();
                renderBoard();
            } catch (error) {
                console.error("Error initializing game:", error);
                if (statusMessageElement) {
                    statusMessageElement.textContent = 'Error! Refresh page.';
                    statusMessageElement.classList.remove('hidden', 'bg-green-100', 'text-green-700', 'dark:bg-green-800', 'dark:text-green-200');
                    statusMessageElement.classList.add('bg-red-100', 'text-red-700', 'dark:bg-red-800', 'dark:text-red-200');
                }
            }
        }
    
        function createBoardDataStructure() {
            boardData = [];
            for (let r = 0; r < ROWS; r++) {
                const row = [];
                for (let c = 0; c < COLS; c++) {
                    row.push({
                        mine: false,
                        revealed: false,
                        flagged: false,
                        adjacentMines: 0,
                        element: null
                    });
                }
                boardData.push(row);
            }
        }
    
        function placeMines() {
            let minesPlaced = 0;
            while (minesPlaced < NUM_MINES) {
                const r = Math.floor(Math.random() * ROWS);
                const c = Math.floor(Math.random() * COLS);
                if (!boardData[r][c].mine) {
                    boardData[r][c].mine = true;
                    minesPlaced++;
                }
            }
        }
    
        function calculateAdjacentMines() {
            for (let r = 0; r < ROWS; r++) {
                for (let c = 0; c < COLS; c++) {
                    if (boardData[r][c].mine) {
                        boardData[r][c].adjacentMines = -1;
                        continue;
                    }
                    let mineCount = 0;
                    getNeighbors(r, c).forEach(([nr, nc]) => {
                        if (boardData[nr][nc].mine) {
                            mineCount++;
                        }
                    });
                    boardData[r][c].adjacentMines = mineCount;
                }
            }
        }
    
        function renderBoard() {
            if (!gameBoardElement) return;
            gameBoardElement.innerHTML = '';
            gameBoardElement.style.gridTemplateColumns = `repeat(${COLS}, minmax(0, 1fr))`;
    
            for (let r = 0; r < ROWS; r++) {
                for (let c = 0; c < COLS; c++) {
                    const cellElement = document.createElement('button');
                    cellElement.setAttribute('data-row', r);
                    cellElement.setAttribute('data-col', c);
    
                    boardData[r][c].element = cellElement;
                    updateCellDOM(r, c); 
    
                    cellElement.addEventListener('click', () => handleCellClick(r, c));
                    cellElement.addEventListener('contextmenu', (e) => {
                        e.preventDefault();
                        handleCellRightClick(r, c);
                    });
    
                    let pressTimer;
                    cellElement.addEventListener('touchstart', (e) => {
                        if (gameState === 'won' || gameState === 'lost' || boardData[r][c].revealed) return;
                        e.preventDefault();
                        pressTimer = setTimeout(() => {
                            handleCellRightClick(r,c);
                            if (navigator.vibrate) navigator.vibrate(50);
                        }, 500);
                    }, {passive: false});
    
                    cellElement.addEventListener('touchend', () => clearTimeout(pressTimer));
                    cellElement.addEventListener('touchmove', () => clearTimeout(pressTimer));
                    cellElement.addEventListener('touchcancel', () => clearTimeout(pressTimer));
    
                    gameBoardElement.appendChild(cellElement);
                }
            }
        }
    
        function handleCellClick(r, c) {
            if (gameState === 'won' || gameState === 'lost') return;
    
            const cellDataInitial = boardData[r][c];
            if (cellDataInitial.revealed || cellDataInitial.flagged) return;
    
            if (firstClick) {
                if (cellDataInitial.mine) {
                    relocateMineAndRecalculate(r, c);
                }
                firstClick = false;
                gameState = 'playing';
                startTimer();
            }
    
            const cellData = boardData[r][c]; 
    
            if (cellData.mine) {
                cellData.revealed = true;
                updateCellDOM(r, c, false, true); 
                gameOver(false);
            } else {
                revealCellRecursive(r, c);
                checkWinCondition();
            }
        }
    
        function relocateMineAndRecalculate(clickedRow, clickedCol) {
            boardData[clickedRow][clickedCol].mine = false;
            let newR, newC;
            do {
                newR = Math.floor(Math.random() * ROWS);
                newC = Math.floor(Math.random() * COLS);
            } while ((newR === clickedRow && newC === clickedCol) || boardData[newR][newC].mine);
            boardData[newR][newC].mine = true;
            calculateAdjacentMines(); 
        }
    
        function handleCellRightClick(r, c) {
            if (gameState === 'won' || gameState === 'lost') return;
            const cellData = boardData[r][c];
            if (cellData.revealed) return;
    
            cellData.flagged = !cellData.flagged;
            minesToFlag += cellData.flagged ? -1 : 1;
    
            updateMineCounterDisplay();
            updateCellDOM(r, c); 
        }
    
        function revealCellRecursive(r, c) {
            if (r < 0 || r >= ROWS || c < 0 || c >= COLS) return;
            const cellData = boardData[r][c];
            if (cellData.revealed || cellData.flagged || cellData.mine) return;
    
            cellData.revealed = true;
            revealedSafeCells++;
            updateCellDOM(r, c); 
    
            if (cellData.adjacentMines === 0) {
                getNeighbors(r, c).forEach(([nr, nc]) => {
                    revealCellRecursive(nr, nc);
                });
            }
        }
    
        function getNeighbors(r, c) {
            const neighbors = [];
            for (let dr = -1; dr <= 1; dr++) {
                for (let dc = -1; dc <= 1; dc++) {
                    if (dr === 0 && dc === 0) continue;
                    const nr = r + dr;
                    const nc = c + dc;
                    if (nr >= 0 && nr < ROWS && nc >= 0 && nc < COLS) {
                        neighbors.push([nr, nc]);
                    }
                }
            }
            return neighbors;
        }
    
        function checkWinCondition() {
            if (revealedSafeCells === totalSafeCells) {
                gameOver(true); 
            }
        }
    
        function gameOver(isWin) {
            gameState = isWin ? 'won' : 'lost';
            clearInterval(timerInterval); 
            if(resetButtonElement) resetButtonElement.textContent = isWin ? '🥳' : '😵';
    
            if(statusMessageElement) {
                statusMessageElement.classList.remove('hidden');
                if (isWin) {
                    statusMessageElement.textContent = 'You Win! 🎉';
                    statusMessageElement.classList.remove('bg-red-100', 'text-red-700', 'dark:bg-red-800', 'dark:text-red-200');
                    statusMessageElement.classList.add('bg-green-100', 'text-green-700', 'dark:bg-green-700', 'dark:text-green-100');
        
                    for (let r_idx = 0; r_idx < ROWS; r_idx++) {
                        for (let c_idx = 0; c_idx < COLS; c_idx++) {
                            if (boardData[r_idx][c_idx].mine && !boardData[r_idx][c_idx].flagged) {
                                boardData[r_idx][c_idx].flagged = true;
                            }
                        }
                    }
                    minesToFlag = 0;
                    updateMineCounterDisplay();
                } else { 
                    statusMessageElement.textContent = 'Game Over! 💣';
                    statusMessageElement.classList.remove('bg-green-100', 'text-green-700', 'dark:bg-green-700', 'dark:text-green-100');
                    statusMessageElement.classList.add('bg-red-100', 'text-red-700', 'dark:bg-red-700', 'dark:text-red-100');
        
                    for (let r_idx = 0; r_idx < ROWS; r_idx++) {
                        for (let c_idx = 0; c_idx < COLS; c_idx++) {
                            const cell = boardData[r_idx][c_idx];
                            if (cell.mine && !cell.revealed) { 
                                cell.revealed = true;
                            } else if (!cell.mine && cell.flagged) { 
                                cell.revealed = true; 
                            }
                        }
                    }
                }
            }
    
            for (let r_idx = 0; r_idx < ROWS; r_idx++) {
                for (let c_idx = 0; c_idx < COLS; c_idx++) {
                    updateCellDOM(r_idx, c_idx, false, false);
                }
            }
        }
        
        function updateCellDOM(r, c, _deprecatedIncorrectFlag = false, isHitMineOnThisCall = false) {
            const cellData = boardData[r][c];
            const cellElement = cellData.element;
            if (!cellElement) return;
    
            if (gameState === 'lost' && !isHitMineOnThisCall && cellElement.classList.contains('mine-hit')) {
                cellElement.disabled = true;
                cellElement.className = 'font-bold text-base sm:text-lg md:text-xl flex items-center justify-center w-full aspect-square rounded-sm transition-colors duration-75 focus:outline-none focus:ring-1 focus:ring-blue-500 dark:focus:ring-blue-400 focus:z-10';
                cellElement.classList.add('bg-red-500', 'dark:bg-red-600', 'text-black', 'dark:text-white', 'mine-hit', 'cursor-default');
                cellElement.textContent = '💥';
                cellElement.classList.remove('hover:bg-slate-300/80', 'active:bg-slate-400/80', 'hover:bg-blue-400', 'dark:hover:bg-slate-500/80', 'dark:active:bg-slate-600/80', 'dark:hover:bg-blue-600');
                return;
            }
    
            cellElement.className = 'font-bold text-base sm:text-lg md:text-xl flex items-center justify-center w-full aspect-square rounded-sm transition-colors duration-75 focus:outline-none focus:ring-1 focus:ring-blue-500 dark:focus:ring-blue-400 focus:z-10';
            cellElement.innerHTML = '';
            cellElement.disabled = false; 
    
            if (isHitMineOnThisCall) { 
                cellElement.classList.add('bg-red-500', 'dark:bg-red-600', 'text-black', 'dark:text-white', 'mine-hit');
                cellElement.textContent = '💥';
                cellElement.disabled = true;
            } else if (cellData.revealed) {
                cellElement.classList.add('bg-slate-200/80', 'dark:bg-slate-700/80', 'border', 'border-slate-300/80', 'dark:border-slate-600/80');
                cellElement.disabled = true; 
    
                if (cellData.mine) { 
                    cellElement.classList.add('bg-slate-500', 'dark:bg-slate-600', 'text-black', 'dark:text-slate-100');
                    cellElement.textContent = '💣';
                } else if (!cellData.mine && cellData.flagged) { 
                    cellElement.classList.add('bg-orange-200', 'dark:bg-orange-600', 'text-orange-700', 'dark:text-orange-100');
                    cellElement.innerHTML = '❌';
                } else if (cellData.adjacentMines > 0) {
                    cellElement.textContent = cellData.adjacentMines;
                    const numColorClass = numberColors[cellData.adjacentMines] || 'text-slate-700 dark:text-slate-300';
                    cellElement.classList.add(...numColorClass.split(' '));
                }
            } else if (cellData.flagged) {
                cellElement.classList.add('bg-blue-300', 'dark:bg-blue-700', 'text-red-600', 'dark:text-red-400', 'border', 'border-blue-400/50', 'dark:border-blue-600/50');
                cellElement.textContent = '🚩';
                if (gameState !== 'won' && gameState !== 'lost') { 
                    cellElement.classList.add('hover:bg-blue-400', 'dark:hover:bg-blue-600');
                }
            } else { 
                cellElement.classList.add('bg-slate-300', 'dark:bg-slate-500', 'border', 'border-slate-400/50', 'dark:border-slate-600/50', 'shadow-[inset_1px_1px_1px_#FFFFFF70,inset_-1px_-1px_1px_#00000030]', 'dark:shadow-[inset_1px_1px_1px_#FFFFFF1A,inset_-1px_-1px_1px_#00000050]');
                if (gameState !== 'won' && gameState !== 'lost') { 
                    cellElement.classList.add('hover:bg-slate-300/80', 'dark:hover:bg-slate-500/80', 'active:bg-slate-400/80', 'dark:active:bg-slate-600/80');
                }
            }
    
            if (gameState === 'won' || gameState === 'lost') {
                cellElement.disabled = true; 
                cellElement.classList.add('cursor-default');
    
                if (cellData.flagged) {
                    cellElement.classList.remove('hover:bg-blue-400', 'dark:hover:bg-blue-600');
                } else if (!cellData.revealed) { 
                    cellElement.classList.remove('hover:bg-slate-300/80', 'dark:hover:bg-slate-500/80', 'active:bg-slate-400/80', 'dark:active:bg-slate-600/80');
                    cellElement.classList.remove('shadow-[inset_1px_1px_1px_#FFFFFF70,inset_-1px_-1px_1px_#00000030]', 'dark:shadow-[inset_1px_1px_1px_#FFFFFF1A,inset_-1px_-1px_1px_#00000050]');
                }
            }
        }
    
        function updateTimerDisplay() {
            if(timerElement) timerElement.textContent = `T:${String(secondsElapsed).padStart(3, '0')}`;
        }
    
        function updateMineCounterDisplay() {
            if(mineCounterElement) mineCounterElement.textContent = `M:${String(minesToFlag).padStart(3, '0')}`;
        }
    
        function startTimer() {
            if (timerInterval) clearInterval(timerInterval);
            updateTimerDisplay(); 
            timerInterval = setInterval(() => {
                secondsElapsed++;
                if (secondsElapsed > 999) secondsElapsed = 999; 
                updateTimerDisplay();
            }, 1000);
        }
        
        // Theme Toggle Logic
        function applyTheme(theme) {
            // console.log(`applyTheme called with: ${theme}`);
            if (!themeToggleButton || !(themeToggleButton instanceof HTMLButtonElement)) {
                 console.error("Theme toggle button is NOT a valid button element in applyTheme.");
                 return;
            }

            if (theme === 'dark') {
                document.documentElement.classList.add('dark');
                themeToggleButton.textContent = '☀️'; 
                localStorage.setItem('theme', 'dark');
            } else {
                document.documentElement.classList.remove('dark');
                themeToggleButton.textContent = '🌙'; 
                localStorage.setItem('theme', 'light');
            }
            // console.log("Applied theme. HTML classes:", document.documentElement.className);
        }

        function toggleTheme() {
            // console.log("toggleTheme called.");
            if (document.documentElement.classList.contains('dark')) {
                applyTheme('light');
            } else {
                applyTheme('dark');
            }
        }
    
        document.addEventListener('DOMContentLoaded', () => {
            console.log("DOMContentLoaded FIRED.");
            console.log("themeToggleButton on DOMContentLoaded:", themeToggleButton);
            console.log("resetButtonElement on DOMContentLoaded:", resetButtonElement);

            const storedTheme = localStorage.getItem('theme');
            const prefersDark = window.matchMedia && window.matchMedia('(prefers-color-scheme: dark)').matches;
            let initialTheme = 'light';

            if (storedTheme) {
                initialTheme = storedTheme;
            } else if (prefersDark) {
                initialTheme = 'dark';
            }
            
            console.log(`Initial theme determined as: ${initialTheme}`);
            applyTheme(initialTheme);
            
            if (themeToggleButton && themeToggleButton instanceof HTMLButtonElement) {
                themeToggleButton.addEventListener('click', toggleTheme);
                console.log("Event listener ADDED to themeToggleButton.");
            } else {
                console.error("Theme toggle button not found or not valid. CANNOT ADD LISTENER.", themeToggleButton);
            }

            if (resetButtonElement && resetButtonElement instanceof HTMLButtonElement) {
                resetButtonElement.addEventListener('click', initGame);
                console.log("Event listener ADDED to resetButtonElement.");
            } else {
                console.error("Reset button not found or not valid. CANNOT ADD LISTENER.", resetButtonElement);
            }
            
            initGame();
            console.log("initGame called AFTER setup in DOMContentLoaded.");
        });
    </script>
</body>
</html>
