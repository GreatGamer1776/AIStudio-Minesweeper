<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Minesweeper</title>
    <script src="https://cdn.tailwindcss.com"></script>
    <style>
        /* Ensuring Inter font is prioritized as per requirement, although Tailwind's font-sans often includes it. */
        /* For strict adherence without a custom Tailwind config, this helps. */
        body {
            font-family: 'Inter', ui-sans-serif, system-ui, -apple-system, BlinkMacSystemFont, "Segoe UI", Roboto, "Helvetica Neue", Arial, "Noto Sans", sans-serif, "Apple Color Emoji", "Segoe UI Emoji", "Segoe UI Symbol", "Noto Color Emoji";
        }
        /* Custom class for the 'explosion' effect on the clicked mine */
        .mine-hit {
            animation: mine-explosion 0.5s ease-out;
        }
        @keyframes mine-explosion {
            0% { transform: scale(1); opacity: 1; }
            50% { transform: scale(1.5); opacity: 0.7; }
            100% { transform: scale(1); opacity: 1; }
        }
    </style>
    <link rel="preconnect" href="https://fonts.googleapis.com">
    <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
    <link href="https://fonts.googleapis.com/css2?family=Inter:wght@400;500;700;900&display=swap" rel="stylesheet">
</head>
<body class="bg-slate-100 flex flex-col items-center justify-center min-h-screen p-2 sm:p-4 select-none">

    <div class="game-container bg-slate-200 p-3 sm:p-4 md:p-6 rounded-xl shadow-xl w-full max-w-xs sm:max-w-sm md:max-w-md lg:max-w-lg">
        <header class="flex justify-between items-center mb-3 sm:mb-4">
            <div id="mine-counter" class="bg-slate-800 text-white px-3 py-1.5 rounded-lg text-lg sm:text-xl font-mono shadow-sm tabular-nums">
                M:015
            </div>
            <button id="reset-button" class="bg-blue-500 hover:bg-blue-600 active:bg-blue-700 text-white font-bold py-1.5 px-3 sm:py-2 sm:px-4 rounded-lg text-base sm:text-lg shadow-sm transition-colors focus:outline-none focus:ring-2 focus:ring-blue-400 focus:ring-opacity-75">
                ðŸ™‚
            </button>
            <div id="timer" class="bg-slate-800 text-white px-3 py-1.5 rounded-lg text-lg sm:text-xl font-mono shadow-sm tabular-nums">
                T:000
            </div>
        </header>

        <div id="status-message" class="text-center text-xl sm:text-2xl font-bold py-2 sm:py-3 mb-2 sm:mb-3 rounded-lg hidden transition-all">
            <!-- Game status will appear here -->
        </div>

        <div id="game-board" class="grid gap-0.5 sm:gap-1 bg-slate-400 p-0.5 sm:p-1 rounded-lg shadow-inner">
            <!-- Cells will be generated by JavaScript -->
        </div>
    </div>

    <footer class="mt-4 sm:mt-6 text-center text-xs sm:text-sm text-slate-600">
        <p>Left-click to reveal. Right-click or long-press (mobile) to flag.</p>
    </footer>

    <script>
        const gameBoardElement = document.getElementById('game-board');
        const mineCounterElement = document.getElementById('mine-counter');
        const timerElement = document.getElementById('timer');
        const resetButtonElement = document.getElementById('reset-button');
        const statusMessageElement = document.getElementById('status-message');
    
        // Game settings
        const ROWS = 10;
        const COLS = 10;
        const NUM_MINES = 15;
    
        let boardData = [];
        let gameState = 'initial'; // 'initial', 'playing', 'won', 'lost'
        let minesToFlag = 0;
        let revealedSafeCells = 0;
        const totalSafeCells = ROWS * COLS - NUM_MINES;
    
        let timerInterval;
        let secondsElapsed = 0;
        let firstClick = true;
    
        const numberColors = [
            '',
            'text-blue-600',    // 1
            'text-green-600',   // 2
            'text-red-600',     // 3
            'text-purple-700',  // 4
            'text-yellow-700',  // 5
            'text-cyan-600',    // 6
            'text-slate-800',   // 7
            'text-slate-500'    // 8
        ];
    
        function initGame() {
            try {
                gameState = 'initial';
                firstClick = true;
                secondsElapsed = 0;
                revealedSafeCells = 0;
                minesToFlag = NUM_MINES;
    
                clearInterval(timerInterval);
                updateTimerDisplay();
                updateMineCounterDisplay();
                resetButtonElement.textContent = 'ðŸ™‚';
    
                statusMessageElement.classList.add('hidden');
                statusMessageElement.textContent = '';
                statusMessageElement.classList.remove('bg-green-100', 'text-green-700', 'bg-red-100', 'text-red-700');
    
                createBoardDataStructure();
                placeMines();
                calculateAdjacentMines();
                renderBoard();
            } catch (error) {
                console.error("Error initializing game:", error);
                statusMessageElement.textContent = 'Error! Refresh page.';
                statusMessageElement.classList.remove('hidden', 'bg-green-100', 'text-green-700');
                statusMessageElement.classList.add('bg-red-100', 'text-red-700');
            }
        }
    
        function createBoardDataStructure() {
            boardData = [];
            for (let r = 0; r < ROWS; r++) {
                const row = [];
                for (let c = 0; c < COLS; c++) {
                    row.push({
                        mine: false,
                        revealed: false,
                        flagged: false,
                        adjacentMines: 0,
                        element: null
                    });
                }
                boardData.push(row);
            }
        }
    
        function placeMines() {
            let minesPlaced = 0;
            while (minesPlaced < NUM_MINES) {
                const r = Math.floor(Math.random() * ROWS);
                const c = Math.floor(Math.random() * COLS);
                if (!boardData[r][c].mine) {
                    boardData[r][c].mine = true;
                    minesPlaced++;
                }
            }
        }
    
        function calculateAdjacentMines() {
            for (let r = 0; r < ROWS; r++) {
                for (let c = 0; c < COLS; c++) {
                    if (boardData[r][c].mine) {
                        boardData[r][c].adjacentMines = -1;
                        continue;
                    }
                    let mineCount = 0;
                    getNeighbors(r, c).forEach(([nr, nc]) => {
                        if (boardData[nr][nc].mine) {
                            mineCount++;
                        }
                    });
                    boardData[r][c].adjacentMines = mineCount;
                }
            }
        }
    
        function renderBoard() {
            gameBoardElement.innerHTML = '';
            gameBoardElement.style.gridTemplateColumns = `repeat(${COLS}, minmax(0, 1fr))`;
    
            for (let r = 0; r < ROWS; r++) {
                for (let c = 0; c < COLS; c++) {
                    const cellElement = document.createElement('button');
                    cellElement.setAttribute('data-row', r);
                    cellElement.setAttribute('data-col', c);
    
                    boardData[r][c].element = cellElement;
                    updateCellDOM(r, c); // Initial render of the cell
    
                    cellElement.addEventListener('click', () => handleCellClick(r, c));
                    cellElement.addEventListener('contextmenu', (e) => {
                        e.preventDefault();
                        handleCellRightClick(r, c);
                    });
    
                    let pressTimer;
                    cellElement.addEventListener('touchstart', (e) => {
                        if (gameState === 'won' || gameState === 'lost' || boardData[r][c].revealed) return;
                        e.preventDefault();
                        pressTimer = setTimeout(() => {
                            handleCellRightClick(r,c);
                            if (navigator.vibrate) navigator.vibrate(50);
                        }, 500);
                    }, {passive: false});
    
                    cellElement.addEventListener('touchend', () => clearTimeout(pressTimer));
                    cellElement.addEventListener('touchmove', () => clearTimeout(pressTimer));
                    cellElement.addEventListener('touchcancel', () => clearTimeout(pressTimer));
    
                    gameBoardElement.appendChild(cellElement);
                }
            }
        }
    
        function handleCellClick(r, c) {
            if (gameState === 'won' || gameState === 'lost') return;
    
            const cellDataInitial = boardData[r][c];
            if (cellDataInitial.revealed || cellDataInitial.flagged) return;
    
            if (firstClick) {
                if (cellDataInitial.mine) {
                    relocateMineAndRecalculate(r, c);
                }
                firstClick = false;
                gameState = 'playing';
                startTimer();
            }
    
            const cellData = boardData[r][c]; // Re-fetch, as it might have changed
    
            if (cellData.mine) {
                cellData.revealed = true; // Mark as revealed
                // Style the hit mine immediately. This specific styling will be preserved by updateCellDOM logic.
                updateCellDOM(r, c, false, true); // true for isHitMine
                gameOver(false); // Game lost
            } else {
                revealCellRecursive(r, c);
                checkWinCondition();
            }
        }
    
        function relocateMineAndRecalculate(clickedRow, clickedCol) {
            boardData[clickedRow][clickedCol].mine = false;
            let newR, newC;
            do {
                newR = Math.floor(Math.random() * ROWS);
                newC = Math.floor(Math.random() * COLS);
            } while ((newR === clickedRow && newC === clickedCol) || boardData[newR][newC].mine);
            boardData[newR][newC].mine = true;
            calculateAdjacentMines(); // Recalculate all adjacencies
        }
    
        function handleCellRightClick(r, c) {
            if (gameState === 'won' || gameState === 'lost') return;
            const cellData = boardData[r][c];
            if (cellData.revealed) return;
    
            // No need to start timer or change gameState on flag, first reveal click does that.
            cellData.flagged = !cellData.flagged;
            minesToFlag += cellData.flagged ? -1 : 1;
    
            updateMineCounterDisplay();
            updateCellDOM(r, c); // Update only this cell's DOM
        }
    
        function revealCellRecursive(r, c) {
            if (r < 0 || r >= ROWS || c < 0 || c >= COLS) return;
            const cellData = boardData[r][c];
            if (cellData.revealed || cellData.flagged || cellData.mine) return;
    
            cellData.revealed = true;
            revealedSafeCells++;
            updateCellDOM(r, c); // Update this cell's DOM
    
            if (cellData.adjacentMines === 0) {
                getNeighbors(r, c).forEach(([nr, nc]) => {
                    revealCellRecursive(nr, nc);
                });
            }
        }
    
        function getNeighbors(r, c) {
            const neighbors = [];
            for (let dr = -1; dr <= 1; dr++) {
                for (let dc = -1; dc <= 1; dc++) {
                    if (dr === 0 && dc === 0) continue;
                    const nr = r + dr;
                    const nc = c + dc;
                    if (nr >= 0 && nr < ROWS && nc >= 0 && nc < COLS) {
                        neighbors.push([nr, nc]);
                    }
                }
            }
            return neighbors;
        }
    
        function checkWinCondition() {
            if (revealedSafeCells === totalSafeCells) {
                gameOver(true); // Game won
            }
        }
    
        function gameOver(isWin) {
            gameState = isWin ? 'won' : 'lost';
            clearInterval(timerInterval); // Stop the timer
            resetButtonElement.textContent = isWin ? 'ðŸ¥³' : 'ðŸ˜µ';
    
            statusMessageElement.classList.remove('hidden');
            if (isWin) {
                statusMessageElement.textContent = 'You Win! ðŸŽ‰';
                statusMessageElement.classList.remove('bg-red-100', 'text-red-700');
                statusMessageElement.classList.add('bg-green-100', 'text-green-700');
    
                // Auto-flag remaining mines
                for (let r_idx = 0; r_idx < ROWS; r_idx++) {
                    for (let c_idx = 0; c_idx < COLS; c_idx++) {
                        if (boardData[r_idx][c_idx].mine && !boardData[r_idx][c_idx].flagged) {
                            boardData[r_idx][c_idx].flagged = true;
                        }
                    }
                }
                minesToFlag = 0;
                updateMineCounterDisplay();
            } else { // Loss
                statusMessageElement.textContent = 'Game Over! ðŸ’£';
                statusMessageElement.classList.remove('bg-green-100', 'text-green-700');
                statusMessageElement.classList.add('bg-red-100', 'text-red-700');
    
                // Mark other mines and incorrect flags for reveal (data change only)
                // The hit mine is already 'revealed:true' from handleCellClick
                for (let r_idx = 0; r_idx < ROWS; r_idx++) {
                    for (let c_idx = 0; c_idx < COLS; c_idx++) {
                        const cell = boardData[r_idx][c_idx];
                        if (cell.mine && !cell.revealed) { // Reveal unrevealed mines
                            cell.revealed = true;
                        } else if (!cell.mine && cell.flagged) { // Mark incorrect flags for reveal
                            cell.revealed = true; // This allows updateCellDOM to show 'X'
                        }
                    }
                }
            }
    
            // Final pass: update DOM for all cells to reflect game over state
            for (let r_idx = 0; r_idx < ROWS; r_idx++) {
                for (let c_idx = 0; c_idx < COLS; c_idx++) {
                    // For the cell that was clicked to lose, its 'mine-hit' style was applied directly.
                    // updateCellDOM needs to preserve this if called again.
                    // The `isHitMine` argument to updateCellDOM is false here.
                    updateCellDOM(r_idx, c_idx, false, false);
                }
            }
        }
        
        // `isHitMineOnThisCall` is true ONLY when handleCellClick calls this for the clicked mine.
        // It's false for general updates, like from the gameOver loop.
        function updateCellDOM(r, c, _deprecatedIncorrectFlag = false, isHitMineOnThisCall = false) {
            const cellData = boardData[r][c];
            const cellElement = cellData.element;
            if (!cellElement) return;
    
            // If game is lost, and this cell IS the one that was hit (has 'mine-hit' class),
            // AND this is NOT the initial call that set it (isHitMineOnThisCall is false),
            // then just ensure it's disabled and return to preserve its ðŸ’¥ style.
            if (gameState === 'lost' && !isHitMineOnThisCall && cellElement.classList.contains('mine-hit')) {
                cellElement.disabled = true;
                cellElement.classList.add('cursor-default');
                // Ensure any hover/active classes (though unlikely) are removed
                cellElement.classList.remove('hover:bg-slate-300/80', 'active:bg-slate-400/80', 'hover:bg-blue-400');
                return;
            }
    
            // Reset common properties
            cellElement.className = 'font-bold text-base sm:text-lg md:text-xl flex items-center justify-center w-full aspect-square rounded-sm transition-colors duration-75 focus:outline-none focus:ring-1 focus:ring-blue-500 focus:z-10';
            cellElement.innerHTML = '';
            cellElement.disabled = false; // Default: not disabled (will be overridden if needed)
    
            if (isHitMineOnThisCall) { // The specific mine that was clicked to end the game
                cellElement.classList.add('bg-red-500', 'text-black', 'mine-hit');
                cellElement.textContent = 'ðŸ’¥';
                cellElement.disabled = true;
            } else if (cellData.revealed) {
                cellElement.classList.add('bg-slate-200/80', 'border', 'border-slate-300/80');
                cellElement.disabled = true; // All revealed cells are disabled
    
                if (cellData.mine) { // Revealed mine (not the one specifically clicked)
                    cellElement.classList.add('bg-slate-500', 'text-black');
                    cellElement.textContent = 'ðŸ’£';
                } else if (!cellData.mine && cellData.flagged) { // Incorrectly flagged non-mine (now revealed)
                    cellElement.classList.add('bg-orange-200', 'text-orange-700');
                    cellElement.innerHTML = 'âŒ';
                } else if (cellData.adjacentMines > 0) {
                    cellElement.textContent = cellData.adjacentMines;
                    cellElement.classList.add(numberColors[cellData.adjacentMines] || 'text-slate-700');
                }
                // If adjacentMines is 0, it's an empty revealed cell, already styled bg-slate-200/80.
            } else if (cellData.flagged) {
                cellElement.classList.add('bg-blue-300', 'text-red-600', 'border', 'border-blue-400/50');
                cellElement.textContent = 'ðŸš©';
                if (gameState !== 'won' && gameState !== 'lost') { // Only add hover if game is active
                    cellElement.classList.add('hover:bg-blue-400');
                }
            } else { // Unrevealed, unflagged cell
                cellElement.classList.add('bg-slate-300', 'border', 'border-slate-400/50', 'shadow-[inset_1px_1px_1px_#FFFFFF70,inset_-1px_-1px_1px_#00000030]');
                if (gameState !== 'won' && gameState !== 'lost') { // Only add hover/active if game is active
                    cellElement.classList.add('hover:bg-slate-300/80', 'active:bg-slate-400/80');
                }
            }
    
            // Apply final game-over states if applicable (and not returned early for the hit mine)
            if (gameState === 'won' || gameState === 'lost') {
                cellElement.disabled = true; // Ensure all cells are disabled on game over
                cellElement.classList.add('cursor-default');
    
                // Remove hover/active effects if cell was styled for active play
                if (cellData.flagged) {
                    cellElement.classList.remove('hover:bg-blue-400');
                } else if (!cellData.revealed) { // Unrevealed, unflagged cells get flattened
                    cellElement.classList.remove('hover:bg-slate-300/80', 'active:bg-slate-400/80');
                    cellElement.classList.remove('shadow-[inset_1px_1px_1px_#FFFFFF70,inset_-1px_-1px_1px_#00000030]');
                    cellElement.classList.add('bg-slate-300/70'); // Muted appearance
                }
                // For revealed cells (numbers, empty, other mines ðŸ’£) or the hit mine (ðŸ’¥),
                // their main style is already set. `disabled` and `cursor-default` are the key additions here.
            }
        }
    
    
        function updateTimerDisplay() {
            timerElement.textContent = `T:${String(secondsElapsed).padStart(3, '0')}`;
        }
    
        function updateMineCounterDisplay() {
            mineCounterElement.textContent = `M:${String(minesToFlag).padStart(3, '0')}`;
        }
    
        function startTimer() {
            if (timerInterval) clearInterval(timerInterval);
            // secondsElapsed = 0; // Resetting here means timer always starts from 0 on first click
            updateTimerDisplay(); // Show 000 immediately (or current if not reset)
            timerInterval = setInterval(() => {
                secondsElapsed++;
                if (secondsElapsed > 999) secondsElapsed = 999; // Max display
                updateTimerDisplay();
            }, 1000);
        }
    
        resetButtonElement.addEventListener('click', initGame);
        document.addEventListener('DOMContentLoaded', initGame);
    </script>
</body>
</html>
